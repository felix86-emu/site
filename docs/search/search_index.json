{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>Welcome to the felix86 documentation.</p> <p>This documentation will help you install felix86 and use it with various configurations and programs.</p>"},{"location":"devs/allocations/","title":"Allocations","text":"<p>GPRs and XMMs are statically allocated. This is faster, less bug-prone and easier, and we can afford to do it because x86-64 has 16 GPRs/XMMs while RISC-V has 32 GPRs/Vecs.</p> <p>The four most used x86 flags (CF/ZF/SF/OF) are also statically allocated to a GPR. While it may seem wasteful, there seems to be a noticeable performance improvement over storing all flags in one register and unpacking them when they need to be used.</p> <p>The AF/PF and other flags are not allocated to a register and immediately written to memory when their value changes.</p> <p>The x87 registers are not statically allocated. Instead, we assign FPRs to them as they get loaded and keep track of push/pop operations to avoid having to do excessive loading/storing. Same applies to MMX registers, as their data is shared with x87 registers we do not statically allocate them.</p> <p>When in JIT code, the following allocation scheme takes place:</p> Representation RISC-V register <code>rax</code> <code>x5</code> / <code>t0</code> <code>rcx</code> <code>x26</code> / <code>s10</code> <code>rdx</code> <code>x12</code> / <code>a2</code> <code>rbx</code> <code>x8</code> / <code>s0</code> <code>rsp</code> <code>x9</code> / <code>s1</code> <code>rbp</code> <code>x18</code> / <code>s2</code> <code>rdi</code> <code>x11</code> / <code>a1</code> <code>rsi</code> <code>x10</code> / <code>a0</code> <code>r8</code> <code>x14</code> / <code>a4</code> <code>r9</code> <code>x15</code> / <code>a5</code> <code>r10</code> <code>x13</code> / <code>a3</code> <code>r11</code> <code>x16</code> / <code>a6</code> <code>r12</code> <code>x17</code> / <code>a7</code> <code>r13</code> <code>x22</code> / <code>s6</code> <code>r14</code> <code>x19</code> / <code>s3</code> <code>r15</code> <code>x20</code> / <code>s4</code> <code>rip</code> (start of current block) <code>x3</code> / <code>gp</code><sup>1</sup> <code>cf</code> <code>x21</code> / <code>s5</code> <code>zf</code> <code>x23</code> / <code>s7</code> <code>sf</code> <code>x24</code> / <code>s8</code> <code>of</code> <code>x25</code> / <code>s9</code> <code>xmm0</code> - <code>xmm15</code> <code>v16</code> - <code>v31</code><sup>2</sup> <code>ThreadState*</code> <code>x27</code> / <code>s11</code> TLS <code>x4</code> / <code>tp</code> Host stack <code>x2</code> / <code>sp</code> Vector mask register <code>v0</code> Allocatable FPRs for x87 <code>ft0</code> - <code>ft7</code> Allocatable Vecs for MMX <code>v8</code> - <code>v15</code> GPR temporaries <code>x1</code>, <code>x6</code>, <code>x28</code>, <code>x29</code>, <code>x7</code>, <code>x30</code>, <code>x31</code> Vec temporaries <code>v1</code>, <code>v2</code>, <code>v3</code>, <code>v4</code>, <code>v5</code>, <code>v6</code>, <code>v7</code> FPR temporaries <code>ft8</code>, <code>ft9</code>, <code>ft10</code>, <code>ft11</code> <p>Note</p> <p>Most of the GPR related allocations don\u2019t have a meaning behind their allocated RISC-V register and are purely random, except for <code>rdi</code>/<code>rsi</code>/<code>rdx</code>/<code>r10</code>/<code>r8</code>/<code>r9</code> which are allocated to <code>a0</code> - <code>a5</code>, following the x86-64 syscall ABI. This is currently unused but in a future version will allow saving some instructions when inlining certain syscalls.</p> <ol> <li> <p>We compile felix86 with <code>-mno-relax</code>, which frees up the <code>gp</code> register for us to use in the JIT.\u00a0\u21a9</p> </li> <li> <p>Using sequential registers starting with a number divisible by eight allows us to do grouping with eight registers for operations that need it.\u00a0\u21a9</p> </li> </ol>"},{"location":"devs/building-instructions/","title":"Building instructions","text":"<p>The installation script will properly install felix86 and a rootfs for you. These instructions are for developers and users who want to compile felix86 manually.</p>"},{"location":"devs/building-instructions/#building","title":"Building","text":"<p>On a RISC-V machine, you can build same as any other CMake project: <pre><code>cmake -B build\ncmake --build build -j$(nproc)\n</code></pre></p> <p>On an x86 machine, install the <code>riscv64-linux-gnu-gcc</code> cross-compiler and set the toolchain file: <pre><code>cmake -B build -DCMAKE_TOOLCHAIN_FILE=./riscv.cmake\ncmake --build build -j$(nproc)\n</code></pre></p> <p>By default, this build will be <code>RelWithDebInfo</code> to assist with development.</p>"},{"location":"devs/building-instructions/#binfmt_misc","title":"binfmt_misc","text":"<p>felix86 can work without being registered to binfmt_misc, but AppImage files and setuid applications like <code>sudo</code> won\u2019t work.</p> <p>To register to binfmt_misc run the following command: <pre><code>sudo -E ./build/felix86 -b\n</code></pre></p> <p>Warning</p> <p>Since we use the <code>F</code> flag in binfmt_misc, each new compilation needs a new binfmt_misc registration. As such, always run <code>sudo -E ./build/felix86 -b</code> after compiling to make sure the binfmt_misc version gets updated.</p>"},{"location":"devs/building-instructions/#tests","title":"Tests","text":"<p>You can build the tests by setting the <code>BUILD_TESTS</code> flag during configuration: <pre><code>cmake -B build -DBUILD_TESTS=ON\n</code></pre></p> <p>These include the single instruction tests from FEX-Emu, some unit tests for syscalls and some binary tests.</p> <p>The felix86 CI runs more binary tests than that. If you want to run the binary tests, clone the binary_tests repo: <pre><code>git clone https://github.com/felix86-emu/binary_tests\ncd binary_tests\n</code></pre></p> <p>You can use the <code>install_tests.sh</code> script to download the binary tests: <pre><code>./install_tests.sh $(pwd)/binaries\n</code></pre></p> <p>Then to run the tests, temporarily disable binfmt_misc usage and use the <code>run_tests.sh</code> script: <pre><code>export FELIX86_BINFMT_MISC_INSTALLED=0\n./run_tests.sh /path/to/felix86 $(pwd)/binaries\n</code></pre></p>"},{"location":"devs/building-instructions/#rootfs","title":"Rootfs","text":"<p>If you don\u2019t want to install a rootfs using the installation script, you can build one using Docker.</p> <p>First, you need a Dockerfile: Dockerfile<pre><code>FROM ubuntu:24.04\n\nENV DEBIAN_FRONTEND=noninteractive\n\nCOPY Run.sh /tmp/Run.sh\n\nRUN bash /tmp/Run.sh\n\nWORKDIR /root\n\nCMD [\"/bin/bash\"]\n</code></pre></p> <p>You also need a script to run inside the container: Run.sh<pre><code>#!/bin/bash\napt update\napt upgrade -y\n\n# Install whatever packages you want your rootfs to have\n# apt install hello\n\n# Create a .tar.gz inside the container while excluding the tempfs directories\ntouch archive.tar.gz\ntar  --exclude=archive.tar.gz --exclude=./media --exclude=./mnt --exclude=./root --exclude=./srv --exclude=./boot --exclude=./home --exclude=./run --exclude=./proc --exclude=./sys --exclude=./dev --exclude=./tmp --exclude=./.dockerenv -czf archive.tar.gz .\n</code></pre></p> <p>Now create your rootfs: <pre><code>sudo docker build -t rootfs .\nsudo docker create --name rootfs rootfs\nsudo docker cp rootfs:/archive.tar.gz ./rootfs.tar.gz\nsudo docker rm rootfs\nsudo docker rmi rootfs\n</code></pre></p> <p>This will create an archived and minimal x86-64 Ubuntu rootfs.</p> <p>Extract it using <code>tar -xzf rootfs.tar.gz -C /path/to/rootfs</code> and set it using <code>felix86 -s /absolute/path/to/rootfs</code>.</p> <p>You can install packages inside the rootfs through felix86, or during rootfs creation by changing the <code>Run.sh</code> script.</p> <p>For an idea of what sort of packages you might need, check out the rootfs generator repository.</p>"},{"location":"devs/building-instructions/#important-files","title":"Important files","text":"<p>During rootfs installation, some important files are copied to the rootfs. Currently, these are the following: <pre><code>/etc/mtab\n/etc/passwd\n/etc/passwd-\n/etc/group\n/etc/group-\n/etc/shadow\n/etc/shadow-\n/etc/gshadow\n/etc/gshadow-\n/etc/hosts\n/etc/hostname\n/etc/timezone\n/etc/localtime\n/etc/fstab\n/etc/subuid\n/etc/subgid\n/etc/machine-id\n/etc/resolv.conf\n/etc/sudoers\n</code></pre></p> <p>Copy these to the rootfs while retaining the host permissions like so: <pre><code>sudo cp -rp /etc/mtab $ROOTFS/etc/mtab\n</code></pre></p>"},{"location":"devs/debugging/","title":"Debugging","text":"<p>Debugging is inherently more difficult than most apps, as most of the time you are trying to debug the guest application that is running through an emulator.</p>"},{"location":"devs/debugging/#important-info","title":"Important info","text":"<p>The emulated state of each process exists in the struct <code>ThreadState</code>. \u201cProcess\u201d here refers to all cloned/forked processes, whether they are an actual \u201cthread\u201d or not.</p> <p>This state is statically allocated in the GPR <code>s11</code>.</p> <p>Tip</p> <p>To inspect the current thread\u2019s ThreadState object, you can run <code>p/x *ThreadState::Get()</code>.</p> <p>Warning</p> <p>The register state in this struct may not be fully up to date, if the currently executing code is recompiled code. Some data may be modified in their respective RISC-V registers. To get their value you\u2019d have to inspect the corresponding statically allocated host register. See allocations.</p> <p>When in JIT code, the current block <code>rip</code> is stored in <code>gp</code> register, viewed as <code>p/x $gp</code>. When not in JIT code, it can be viewed as <code>p/x ThreadState::Get()-&gt;rip</code>.</p> <p>Logs for every run are stored in <code>/tmp</code>. If felix86 is started with <code>FELIX86_QUIET</code> or through <code>felix86 --shell</code>, no logs will be generated. You can enter a shell with <code>felix86 /path/to/rootfs/bin/bash</code> to enable logging.</p>"},{"location":"devs/debugging/#useful-functions","title":"Useful functions","text":"<p>When built as <code>RelWithDebInfo</code>, some functions can be called from gdb to assist with debugging.</p> <p>The <code>disassemble(u64)</code> function can disassemble x86 code at an address. When in JIT code, you can view the disassembly of the current block using <code>disassemble($gp)</code>.</p> <p>The <code>print_address(u64)</code> function can print the symbol, if any, at an address.</p>"},{"location":"devs/debugging/#useful-configurations","title":"Useful configurations","text":"<p>The <code>FELIX86_CALLTRACE=1</code> environment variable can generate a calltrace (pushing on calls, popping on rets) that can be printed through the function <code>dump_states()</code>, or when an error happens.</p> <p>The <code>FELIX86_SLEEP_ERROR=1</code> environment variable will sleep the thread and print the PID on exit to allow for gdb to attach and get a backtrace.</p> <p>The <code>FELIX86_CAPTURE_SIGSEGV=1</code> and <code>FELIX86_CAPTURE_SIGABRT=1</code> environment variables work similarly. Some applications rely on guest SIGSEGV signals being handled correctly.</p> <p>The <code>FELIX86_ABORT_SIGSEGV=1</code> environment variable will raise a SIGABRT on guest SIGSEGV. This is useful for generating a core dump if core dumps are enabled.</p> <p>The <code>FELIX86_ALIGNMENT_CHECK=1</code> environment variable will insert alignment checks on every atomic instruction to catch unaligned atomics that aren\u2019t properly handled.</p> <p>The <code>FELIX86_PRINT_SIGNALS</code> environment variable will print all guest signals.</p> <p>The <code>FELIX86_PRINT_ALL_SIGNALS</code> environment variable will print all signals, including ones used by felix86.</p> <p>The <code>FELIX86_STRACE</code> environment variable will print info about all syscalls.</p> <p>The <code>FELIX86_STRACE_ERRORS</code> environment variable will print info about all syscalls that return an error.</p>"},{"location":"general/glossary/","title":"Glossary","text":"<p>Some of these terms have specific meanings for felix86 that may not carry over to other projects.</p>"},{"location":"general/glossary/#a","title":"A","text":"<ul> <li>Address cache: A faster guest-to-host translation method that is implemented in RISC-V assembly. The following pseudocode explains how it works:     <pre><code>Translation trans = address_cache[guest_address &amp; 0xFFFF];\nif (trans.guest_address == guest_address) {\n    return trans.host_address;\n} else {\n    // Perform an unordered_map lookup and fill address cache entry\n    return slow_translation(guest_address);\n}\n</code></pre></li> </ul>"},{"location":"general/glossary/#b","title":"B","text":"<ul> <li> <p>Block: A basic block. A sequence of x86 instructions with no control flow until the last instruction of the sequence.</p> </li> <li> <p>Block linking: A common JIT optimization where blocks that jump to a known address jump directly to the next block instead of performing address translation</p> </li> </ul>"},{"location":"general/glossary/#c","title":"C","text":"<ul> <li> <p>\u201cCallret\u201d: A relatively common JIT optimization where return addresses are predicted and the host return stack buffer is used.</p> </li> <li> <p>Code cache: A buffer containing the recompiled code.</p> </li> </ul>"},{"location":"general/glossary/#f","title":"F","text":"<ul> <li>Fake mount: A mechanism within felix86 that allows directories to appear as mounted without actually mounting them or using root permissions. See rootfs.</li> </ul>"},{"location":"general/glossary/#i","title":"I","text":"<ul> <li> <p>Invalidations: Blocks become invalid when their x86 instructions are modified (see SMC). When invalidated, blocks that link to them need to be unlinked and the invalid block needs to be compiled again.</p> </li> <li> <p>Inline SMC: SMC that changes instructions in the current block. Needs extra work to properly handle.</p> </li> </ul>"},{"location":"general/glossary/#r","title":"R","text":"<ul> <li> <p>Rootfs: See rootfs. A directory containing the necessary x86/x86-64 libraries and binaries to run your applications and games.</p> </li> <li> <p>RVA23: A RISC-V profile, which is a set of ISA features, such as RISC-V extensions. Felix86 does not currently require RVA23.</p> </li> <li> <p>RVV: RISC-V Vector, a shorthand name of the vector extension, usually referring to version 1.0</p> </li> </ul>"},{"location":"general/glossary/#s","title":"S","text":"<ul> <li>SMC: Self-modifying code. A recompiler (such as Mono found in Unity games) may modify it\u2019s own code to improve it. Felix86 uses SMC to perform block linking. SMC is detected with page protection of recompiled code.</li> </ul>"},{"location":"general/glossary/#t","title":"T","text":"<ul> <li> <p>Thunks: Special x86 libraries that call into host RISC-V code for performance.</p> </li> <li> <p>Trampolines: Small pieces of assembly code that perform x86 to RISC-V or RISC-V to x86 ABI translations and jump to the recompiled code. The former is used for thunks, the latter is used for x86 callbacks.</p> </li> <li> <p>TSO: Total store ordering, the x86 memory model. RISC-V by default has a weak memory model, except in the presence of RVTSO (which doesn\u2019t exist in hardware).</p> </li> </ul>"},{"location":"general/rootfs-information/","title":"Rootfs information","text":""},{"location":"general/rootfs-information/#what-is-a-rootfs-and-how-is-it-used","title":"What is a rootfs and how is it used?","text":"<p>In order to use felix86, you need a rootfs \u2013 a directory that contains all the x86 libraries that your programs may need. Upon running, felix86 will perform a fake, rootless mount of folders such as <code>/dev</code>, <code>/proc</code>, <code>/sys</code> and others inside the rootfs. Any guest application will solely exist inside the rootfs. For example, if your rootfs is at <code>/opt/felix86/rootfs</code> and a program accesses <code>/home/ubuntu/myfile</code>, this access will be translated to <code>/opt/felix86/rootfs/home/ubuntu/myfile</code> inside the rootfs. This is accomplished by doing full path resolution in userspace, before passing the final resolved and symlink-free path to the kernel. As a consequence, filesystem accesses such as <code>/..</code>, or symlinks that point backwards will not escape the rootfs.<sup>1</sup> From the prespective of the application, it is equivalent to being chrooted inside the rootfs.</p> <p>This means that the rootfs will also contain all the data that applications produce. For example, if a game normally saves to <code>/home/ubuntu/.config/MyGame/data.toml</code>, when ran through felix86 the actual location will be at <code>/opt/felix86/rootfs/home/ubuntu/.config/MyGame/data.toml</code>.</p> <p>You can easily install new packages inside the rootfs. Once inside the felix86 shell (run <code>felix86 --shell</code>) you can use the package manager as normal. For example, if you installed the Ubuntu rootfs, <code>apt</code> can be used.</p>"},{"location":"general/rootfs-information/#does-this-mean-i-can-only-run-applications-that-are-inside-the-rootfs","title":"Does this mean I can only run applications that are inside the rootfs?","text":"<p>No. Recent versions of felix86 implement the concept of \u201ctrusted directories\u201d. The first time you run an application outside the rootfs you will be prompted to trust the parent directory. Doing so will allow you to run the application and any subdirectories and files will be visible to the application. Since guest programs can truly only see inside the rootfs, the fake mount mechanism used for <code>/dev</code> &amp; co is used for trusted directories as well.</p>"},{"location":"general/rootfs-information/#how-can-i-change-my-rootfs","title":"How can I change my rootfs?","text":"<p>As with most configurations, there\u2019s two options:</p> <ul> <li>Set the <code>rootfs</code> option in <code>$HOME/.config/felix86/config.toml</code><ul> <li>Can be done using <code>felix86 -s /path/to/rootfs</code></li> </ul> </li> <li>Set the <code>FELIX86_ROOTFS</code> environment variable (overrides config value)</li> </ul> <ol> <li> <p>That being said, felix86 is not a security application. Only run applications you trust, not malware. VM escapes are possible.\u00a0\u21a9</p> </li> </ol>"},{"location":"users/installation-guide/","title":"Installation guide","text":"<p>Installing felix86 is easiest done with the installation script. Simply paste this into a terminal and press Enter. <pre><code>bash &lt;(curl -s https://install.felix86.com)\n</code></pre></p> <p>This script will guide you through choosing a felix86 version and a rootfs.</p> <p>Consult the usage guide for further info.</p> <p>For manual installation, see the building instructions.</p>"},{"location":"users/steam/","title":"Steam","text":"<p>Installing Steam using felix86 is easy!</p>"},{"location":"users/steam/#installation","title":"Installation","text":"<p>Download the <code>steam_latest.deb</code> package from Steam\u2019s website.</p> <p>Enter <code>felix86 --shell</code> and install it via dpkg: <code>sudo dpkg -i /path/to/steam_latest.deb</code></p>"},{"location":"users/steam/#running","title":"Running","text":"<p>Run as <code>steam -no-cef-sandbox</code>.</p> <p>If you\u2019re having GPU issues, you can also disable the GPU with <code>-cef-disable-gpu</code></p> <p>If you\u2019re having issues on Wayland, you may need <code>SDL_VIDEODRIVER=x11</code>.</p> <p>Tip</p> <p>Since felix86 can use <code>apt</code>, it may be possible to install through the package manager. This is untested.</p>"},{"location":"users/supported-devices/","title":"Supported devices","text":"<p>Felix86 requires <code>rv64gv_zba_zbb_zbc_zbs</code> to work. RVA23 supports all of these extensions, so boards with RVA23 such as future Spacemit K3 boards will be supported.</p> <p>Spacemit K1 boards are also supported.</p> <p>Some examples:</p> <ul> <li>Banana Pi F3 (has mPCIe slot)</li> <li>Milk-V Jupiter (has PCIe slot)</li> <li>DC-ROMA II</li> <li>Muse Pi Pro</li> <li>Orange Pi RV2</li> </ul> <p>A board with a PCIe slot is preferred for connecting a discrete GPU.</p>"},{"location":"users/troubleshooting/","title":"Troubleshooting","text":""},{"location":"users/troubleshooting/#glitching-graphics-with-amd-gpus-and-the-amdgpu-module","title":"Glitching graphics with AMD GPUs and the <code>amdgpu</code> module","text":"<p>There may be problems due to differences in memory models in userspace and kernel drivers, in particular with 64-bit OpenGL applications running with AMD GPUs that use the <code>amdgpu</code> kernel module.</p> <p>Either enable <code>FELIX86_ENABLED_THUNKS=glx</code>, or if running into issues with that, enable TSO with <code>FELIX86_ALWAYS_TSO=1</code>.</p>"},{"location":"users/usage-guide/","title":"Usage guide","text":"<p>A nice and clean start is using the felix86 shell: <pre><code>felix86 --shell\n</code></pre></p> <p>This will disable logging and start a bash or zsh shell with a custom prompt.</p> <p>If you want logging to be enabled, execute the shell manually: <pre><code>felix86 /path/to/rootfs/bin/bash\n</code></pre></p> <p>If you don\u2019t want a shell, you can just run the program directly: <pre><code>felix86 /path/to/rootfs/usr/bin/nano\n</code></pre></p> <p>If installed in binfmt_misc (handled by install script, or with <code>sudo -E felix86 -b</code>) you can simply run x86 programs that are inside the rootfs: <pre><code>/path/to/rootfs/MyGame.AppImage\n</code></pre></p> <p>If you want to run a program outside the rootfs, you will be prompted to trust the parent directory: <pre><code>/path/to/some/dir/MyGame.AppImage\n</code></pre></p>"},{"location":"users/usage-guide/#compatibility","title":"Compatibility","text":"<p>There\u2019s a compatibility list:</p> <p>https://felix86.com/compat/</p> <p>If you want to try a game that is not listed, you can make a compatibility report here:</p> <p>https://github.com/felix86-emu/compatibility-list/issues</p>"},{"location":"users/usage-guide/#thunking","title":"Thunking","text":"<p>There\u2019s thunking support for GLX (OpenGL on X11) and Vulkan. You can enable it using <code>FELIX86_ENABLED_THUNKS=glx,vk</code>. This should improve performance for games.</p>"},{"location":"users/usage-guide/#dxvk","title":"DXVK","text":"<p>Installing DXVK is as simple as installing it on your host system: <pre><code># Set $ROOTFS to the rootfs absolute path for convenience\nexport ROOTFS=$(felix86 -g)\n\n# Copy DXVK release inside rootfs\ncp -r /path/to/dxvk-release $ROOTFS/tmp/\n\n# Enter felix86 shell\nfelix86 --shell\n\nexport WINEPREFIX=/path/to/wineprefix\ncd /tmp/dxvk-release\ncp x64/*.dll $WINEPREFIX/drive_c/windows/system32\ncp x32/*.dll $WINEPREFIX/drive_c/windows/syswow64\n\n# Run winecfg from inside felix86 shell and add native DLL overrides for\n# d3d8, d3d9, d3d10core, d3d11, dxgi.\nwinecfg\n</code></pre></p> <p>Make sure to enable Vulkan thunking for better performance: <pre><code># Needs to be exported before entering felix86 shell\nexport FELIX86_ENABLED_THUNKS=vk\nfelix86 --shell\n</code></pre></p>"}]}